/*
http://www.apache.org/licenses/LICENSE-2.0.txt


Copyright 2016 Intel Corporation

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by protoc-gen-go.
// source: github.com/intelsdi-x/snap/control/plugin/rpc/plugin.proto
// DO NOT EDIT!

/*
Package rpc is a generated protocol buffer package.

It is generated from these files:
	github.com/intelsdi-x/snap/control/plugin/rpc/plugin.proto

It has these top-level messages:
	CollectArg
	CollectReply
	Empty
	ErrReply
	Time
	NamespaceElement
	PubProcArg
	Metric
	ConfigMap
	KillArg
	GetConfigPolicyReply
	BoolRule
	BoolPolicy
	FloatRule
	FloatPolicy
	IntegerRule
	IntegerPolicy
	StringRule
	StringPolicy
	MetricsArg
	MetricsReply
	GetMetricTypesArg
*/
package rpc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion4 // please upgrade the proto package

// Request that can be passed a stream collector
type CollectArg struct {
	// Request these metrics to be collected on the plugins schedule
	Metrics_Arg *MetricsArg `protobuf:"bytes,1,opt,name=Metrics_Arg,json=metricsArg" json:"Metrics_Arg,omitempty"`
	// Set minimum collection duration --duration in ms
	MaxCollectDuration int64 `protobuf:"varint,2,opt,name=MaxCollectDuration,json=maxCollectDuration" json:"MaxCollectDuration,omitempty"`
	// Set max number of metrics to buffer before forcing send
	// 0 means no forced send
	MaxMetricsBuffer int64 `protobuf:"varint,3,opt,name=MaxMetricsBuffer,json=maxMetricsBuffer" json:"MaxMetricsBuffer,omitempty"`
	// Blob of domain specific info
	Other []byte `protobuf:"bytes,4,opt,name=Other,json=other,proto3" json:"Other,omitempty"`
}

func (m *CollectArg) Reset()                    { *m = CollectArg{} }
func (m *CollectArg) String() string            { return proto.CompactTextString(m) }
func (*CollectArg) ProtoMessage()               {}
func (*CollectArg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *CollectArg) GetMetrics_Arg() *MetricsArg {
	if m != nil {
		return m.Metrics_Arg
	}
	return nil
}

// Replies that can be sent from a stream collector
type CollectReply struct {
	// Reply with metrics
	Metrics_Reply *MetricsReply `protobuf:"bytes,1,opt,name=Metrics_Reply,json=metricsReply" json:"Metrics_Reply,omitempty"`
	Error         *ErrReply     `protobuf:"bytes,2,opt,name=Error,json=error" json:"Error,omitempty"`
}

func (m *CollectReply) Reset()                    { *m = CollectReply{} }
func (m *CollectReply) String() string            { return proto.CompactTextString(m) }
func (*CollectReply) ProtoMessage()               {}
func (*CollectReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *CollectReply) GetMetrics_Reply() *MetricsReply {
	if m != nil {
		return m.Metrics_Reply
	}
	return nil
}

func (m *CollectReply) GetError() *ErrReply {
	if m != nil {
		return m.Error
	}
	return nil
}

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type ErrReply struct {
	Error string `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
}

func (m *ErrReply) Reset()                    { *m = ErrReply{} }
func (m *ErrReply) String() string            { return proto.CompactTextString(m) }
func (*ErrReply) ProtoMessage()               {}
func (*ErrReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type Time struct {
	Sec  int64 `protobuf:"varint,1,opt,name=sec" json:"sec,omitempty"`
	Nsec int64 `protobuf:"varint,2,opt,name=nsec" json:"nsec,omitempty"`
}

func (m *Time) Reset()                    { *m = Time{} }
func (m *Time) String() string            { return proto.CompactTextString(m) }
func (*Time) ProtoMessage()               {}
func (*Time) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type NamespaceElement struct {
	Value       string `protobuf:"bytes,1,opt,name=Value,json=value" json:"Value,omitempty"`
	Description string `protobuf:"bytes,2,opt,name=Description,json=description" json:"Description,omitempty"`
	Name        string `protobuf:"bytes,3,opt,name=Name,json=name" json:"Name,omitempty"`
}

func (m *NamespaceElement) Reset()                    { *m = NamespaceElement{} }
func (m *NamespaceElement) String() string            { return proto.CompactTextString(m) }
func (*NamespaceElement) ProtoMessage()               {}
func (*NamespaceElement) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type PubProcArg struct {
	Metrics []*Metric  `protobuf:"bytes,1,rep,name=Metrics,json=metrics" json:"Metrics,omitempty"`
	Config  *ConfigMap `protobuf:"bytes,2,opt,name=Config,json=config" json:"Config,omitempty"`
}

func (m *PubProcArg) Reset()                    { *m = PubProcArg{} }
func (m *PubProcArg) String() string            { return proto.CompactTextString(m) }
func (*PubProcArg) ProtoMessage()               {}
func (*PubProcArg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *PubProcArg) GetMetrics() []*Metric {
	if m != nil {
		return m.Metrics
	}
	return nil
}

func (m *PubProcArg) GetConfig() *ConfigMap {
	if m != nil {
		return m.Config
	}
	return nil
}

// core.Metric
type Metric struct {
	Namespace          []*NamespaceElement `protobuf:"bytes,1,rep,name=Namespace,json=namespace" json:"Namespace,omitempty"`
	Version            int64               `protobuf:"varint,2,opt,name=Version,json=version" json:"Version,omitempty"`
	Config             *ConfigMap          `protobuf:"bytes,3,opt,name=Config,json=config" json:"Config,omitempty"`
	LastAdvertisedTime *Time               `protobuf:"bytes,4,opt,name=LastAdvertisedTime,json=lastAdvertisedTime" json:"LastAdvertisedTime,omitempty"`
	Tags               map[string]string   `protobuf:"bytes,5,rep,name=Tags,json=tags" json:"Tags,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Timestamp          *Time               `protobuf:"bytes,6,opt,name=Timestamp,json=timestamp" json:"Timestamp,omitempty"`
	Unit               string              `protobuf:"bytes,7,opt,name=Unit,json=unit" json:"Unit,omitempty"`
	Description        string              `protobuf:"bytes,8,opt,name=Description,json=description" json:"Description,omitempty"`
	// Types that are valid to be assigned to Data:
	//	*Metric_StringData
	//	*Metric_Float32Data
	//	*Metric_Float64Data
	//	*Metric_Int32Data
	//	*Metric_Int64Data
	//	*Metric_BytesData
	//	*Metric_BoolData
	//	*Metric_Uint32Data
	//	*Metric_Uint64Data
	Data isMetric_Data `protobuf_oneof:"data"`
}

func (m *Metric) Reset()                    { *m = Metric{} }
func (m *Metric) String() string            { return proto.CompactTextString(m) }
func (*Metric) ProtoMessage()               {}
func (*Metric) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

type isMetric_Data interface {
	isMetric_Data()
}

type Metric_StringData struct {
	StringData string `protobuf:"bytes,9,opt,name=string_data,json=stringData,oneof"`
}
type Metric_Float32Data struct {
	Float32Data float32 `protobuf:"fixed32,10,opt,name=float32_data,json=float32Data,oneof"`
}
type Metric_Float64Data struct {
	Float64Data float64 `protobuf:"fixed64,11,opt,name=float64_data,json=float64Data,oneof"`
}
type Metric_Int32Data struct {
	Int32Data int32 `protobuf:"varint,12,opt,name=int32_data,json=int32Data,oneof"`
}
type Metric_Int64Data struct {
	Int64Data int64 `protobuf:"varint,13,opt,name=int64_data,json=int64Data,oneof"`
}
type Metric_BytesData struct {
	BytesData []byte `protobuf:"bytes,14,opt,name=bytes_data,json=bytesData,proto3,oneof"`
}
type Metric_BoolData struct {
	BoolData bool `protobuf:"varint,15,opt,name=bool_data,json=boolData,oneof"`
}
type Metric_Uint32Data struct {
	Uint32Data uint32 `protobuf:"varint,16,opt,name=uint32_data,json=uint32Data,oneof"`
}
type Metric_Uint64Data struct {
	Uint64Data uint64 `protobuf:"varint,17,opt,name=uint64_data,json=uint64Data,oneof"`
}

func (*Metric_StringData) isMetric_Data()  {}
func (*Metric_Float32Data) isMetric_Data() {}
func (*Metric_Float64Data) isMetric_Data() {}
func (*Metric_Int32Data) isMetric_Data()   {}
func (*Metric_Int64Data) isMetric_Data()   {}
func (*Metric_BytesData) isMetric_Data()   {}
func (*Metric_BoolData) isMetric_Data()    {}
func (*Metric_Uint32Data) isMetric_Data()  {}
func (*Metric_Uint64Data) isMetric_Data()  {}

func (m *Metric) GetData() isMetric_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Metric) GetNamespace() []*NamespaceElement {
	if m != nil {
		return m.Namespace
	}
	return nil
}

func (m *Metric) GetConfig() *ConfigMap {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *Metric) GetLastAdvertisedTime() *Time {
	if m != nil {
		return m.LastAdvertisedTime
	}
	return nil
}

func (m *Metric) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Metric) GetTimestamp() *Time {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *Metric) GetStringData() string {
	if x, ok := m.GetData().(*Metric_StringData); ok {
		return x.StringData
	}
	return ""
}

func (m *Metric) GetFloat32Data() float32 {
	if x, ok := m.GetData().(*Metric_Float32Data); ok {
		return x.Float32Data
	}
	return 0
}

func (m *Metric) GetFloat64Data() float64 {
	if x, ok := m.GetData().(*Metric_Float64Data); ok {
		return x.Float64Data
	}
	return 0
}

func (m *Metric) GetInt32Data() int32 {
	if x, ok := m.GetData().(*Metric_Int32Data); ok {
		return x.Int32Data
	}
	return 0
}

func (m *Metric) GetInt64Data() int64 {
	if x, ok := m.GetData().(*Metric_Int64Data); ok {
		return x.Int64Data
	}
	return 0
}

func (m *Metric) GetBytesData() []byte {
	if x, ok := m.GetData().(*Metric_BytesData); ok {
		return x.BytesData
	}
	return nil
}

func (m *Metric) GetBoolData() bool {
	if x, ok := m.GetData().(*Metric_BoolData); ok {
		return x.BoolData
	}
	return false
}

func (m *Metric) GetUint32Data() uint32 {
	if x, ok := m.GetData().(*Metric_Uint32Data); ok {
		return x.Uint32Data
	}
	return 0
}

func (m *Metric) GetUint64Data() uint64 {
	if x, ok := m.GetData().(*Metric_Uint64Data); ok {
		return x.Uint64Data
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Metric) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Metric_OneofMarshaler, _Metric_OneofUnmarshaler, _Metric_OneofSizer, []interface{}{
		(*Metric_StringData)(nil),
		(*Metric_Float32Data)(nil),
		(*Metric_Float64Data)(nil),
		(*Metric_Int32Data)(nil),
		(*Metric_Int64Data)(nil),
		(*Metric_BytesData)(nil),
		(*Metric_BoolData)(nil),
		(*Metric_Uint32Data)(nil),
		(*Metric_Uint64Data)(nil),
	}
}

func _Metric_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Metric)
	// data
	switch x := m.Data.(type) {
	case *Metric_StringData:
		b.EncodeVarint(9<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.StringData)
	case *Metric_Float32Data:
		b.EncodeVarint(10<<3 | proto.WireFixed32)
		b.EncodeFixed32(uint64(math.Float32bits(x.Float32Data)))
	case *Metric_Float64Data:
		b.EncodeVarint(11<<3 | proto.WireFixed64)
		b.EncodeFixed64(math.Float64bits(x.Float64Data))
	case *Metric_Int32Data:
		b.EncodeVarint(12<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Int32Data))
	case *Metric_Int64Data:
		b.EncodeVarint(13<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Int64Data))
	case *Metric_BytesData:
		b.EncodeVarint(14<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.BytesData)
	case *Metric_BoolData:
		t := uint64(0)
		if x.BoolData {
			t = 1
		}
		b.EncodeVarint(15<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *Metric_Uint32Data:
		b.EncodeVarint(16<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Uint32Data))
	case *Metric_Uint64Data:
		b.EncodeVarint(17<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Uint64Data))
	case nil:
	default:
		return fmt.Errorf("Metric.Data has unexpected type %T", x)
	}
	return nil
}

func _Metric_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Metric)
	switch tag {
	case 9: // data.string_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Data = &Metric_StringData{x}
		return true, err
	case 10: // data.float32_data
		if wire != proto.WireFixed32 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed32()
		m.Data = &Metric_Float32Data{math.Float32frombits(uint32(x))}
		return true, err
	case 11: // data.float64_data
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.Data = &Metric_Float64Data{math.Float64frombits(x)}
		return true, err
	case 12: // data.int32_data
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Data = &Metric_Int32Data{int32(x)}
		return true, err
	case 13: // data.int64_data
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Data = &Metric_Int64Data{int64(x)}
		return true, err
	case 14: // data.bytes_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Data = &Metric_BytesData{x}
		return true, err
	case 15: // data.bool_data
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Data = &Metric_BoolData{x != 0}
		return true, err
	case 16: // data.uint32_data
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Data = &Metric_Uint32Data{uint32(x)}
		return true, err
	case 17: // data.uint64_data
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Data = &Metric_Uint64Data{x}
		return true, err
	default:
		return false, nil
	}
}

func _Metric_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Metric)
	// data
	switch x := m.Data.(type) {
	case *Metric_StringData:
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.StringData)))
		n += len(x.StringData)
	case *Metric_Float32Data:
		n += proto.SizeVarint(10<<3 | proto.WireFixed32)
		n += 4
	case *Metric_Float64Data:
		n += proto.SizeVarint(11<<3 | proto.WireFixed64)
		n += 8
	case *Metric_Int32Data:
		n += proto.SizeVarint(12<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Int32Data))
	case *Metric_Int64Data:
		n += proto.SizeVarint(13<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Int64Data))
	case *Metric_BytesData:
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.BytesData)))
		n += len(x.BytesData)
	case *Metric_BoolData:
		n += proto.SizeVarint(15<<3 | proto.WireVarint)
		n += 1
	case *Metric_Uint32Data:
		n += proto.SizeVarint(16<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Uint32Data))
	case *Metric_Uint64Data:
		n += proto.SizeVarint(17<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Uint64Data))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ConfigMap struct {
	IntMap    map[string]int64  `protobuf:"bytes,1,rep,name=IntMap,json=intMap" json:"IntMap,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	StringMap map[string]string `protobuf:"bytes,2,rep,name=StringMap,json=stringMap" json:"StringMap,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// double is float64
	FloatMap map[string]float64 `protobuf:"bytes,3,rep,name=FloatMap,json=floatMap" json:"FloatMap,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"fixed64,2,opt,name=value"`
	BoolMap  map[string]bool    `protobuf:"bytes,4,rep,name=BoolMap,json=boolMap" json:"BoolMap,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
}

func (m *ConfigMap) Reset()                    { *m = ConfigMap{} }
func (m *ConfigMap) String() string            { return proto.CompactTextString(m) }
func (*ConfigMap) ProtoMessage()               {}
func (*ConfigMap) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *ConfigMap) GetIntMap() map[string]int64 {
	if m != nil {
		return m.IntMap
	}
	return nil
}

func (m *ConfigMap) GetStringMap() map[string]string {
	if m != nil {
		return m.StringMap
	}
	return nil
}

func (m *ConfigMap) GetFloatMap() map[string]float64 {
	if m != nil {
		return m.FloatMap
	}
	return nil
}

func (m *ConfigMap) GetBoolMap() map[string]bool {
	if m != nil {
		return m.BoolMap
	}
	return nil
}

type KillArg struct {
	Reason string `protobuf:"bytes,1,opt,name=Reason,json=reason" json:"Reason,omitempty"`
}

func (m *KillArg) Reset()                    { *m = KillArg{} }
func (m *KillArg) String() string            { return proto.CompactTextString(m) }
func (*KillArg) ProtoMessage()               {}
func (*KillArg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type GetConfigPolicyReply struct {
	Error         string                    `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	BoolPolicy    map[string]*BoolPolicy    `protobuf:"bytes,2,rep,name=bool_policy,json=boolPolicy" json:"bool_policy,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	FloatPolicy   map[string]*FloatPolicy   `protobuf:"bytes,3,rep,name=float_policy,json=floatPolicy" json:"float_policy,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	IntegerPolicy map[string]*IntegerPolicy `protobuf:"bytes,4,rep,name=integer_policy,json=integerPolicy" json:"integer_policy,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	StringPolicy  map[string]*StringPolicy  `protobuf:"bytes,5,rep,name=string_policy,json=stringPolicy" json:"string_policy,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *GetConfigPolicyReply) Reset()                    { *m = GetConfigPolicyReply{} }
func (m *GetConfigPolicyReply) String() string            { return proto.CompactTextString(m) }
func (*GetConfigPolicyReply) ProtoMessage()               {}
func (*GetConfigPolicyReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *GetConfigPolicyReply) GetBoolPolicy() map[string]*BoolPolicy {
	if m != nil {
		return m.BoolPolicy
	}
	return nil
}

func (m *GetConfigPolicyReply) GetFloatPolicy() map[string]*FloatPolicy {
	if m != nil {
		return m.FloatPolicy
	}
	return nil
}

func (m *GetConfigPolicyReply) GetIntegerPolicy() map[string]*IntegerPolicy {
	if m != nil {
		return m.IntegerPolicy
	}
	return nil
}

func (m *GetConfigPolicyReply) GetStringPolicy() map[string]*StringPolicy {
	if m != nil {
		return m.StringPolicy
	}
	return nil
}

type BoolRule struct {
	Required   bool `protobuf:"varint,1,opt,name=required" json:"required,omitempty"`
	Default    bool `protobuf:"varint,2,opt,name=default" json:"default,omitempty"`
	HasDefault bool `protobuf:"varint,3,opt,name=has_default,json=hasDefault" json:"has_default,omitempty"`
}

func (m *BoolRule) Reset()                    { *m = BoolRule{} }
func (m *BoolRule) String() string            { return proto.CompactTextString(m) }
func (*BoolRule) ProtoMessage()               {}
func (*BoolRule) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

type BoolPolicy struct {
	Rules map[string]*BoolRule `protobuf:"bytes,1,rep,name=rules" json:"rules,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Key   []string             `protobuf:"bytes,2,rep,name=key" json:"key,omitempty"`
}

func (m *BoolPolicy) Reset()                    { *m = BoolPolicy{} }
func (m *BoolPolicy) String() string            { return proto.CompactTextString(m) }
func (*BoolPolicy) ProtoMessage()               {}
func (*BoolPolicy) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *BoolPolicy) GetRules() map[string]*BoolRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

type FloatRule struct {
	Required   bool    `protobuf:"varint,1,opt,name=required" json:"required,omitempty"`
	Minimum    float64 `protobuf:"fixed64,2,opt,name=minimum" json:"minimum,omitempty"`
	Maximum    float64 `protobuf:"fixed64,3,opt,name=maximum" json:"maximum,omitempty"`
	Default    float64 `protobuf:"fixed64,4,opt,name=default" json:"default,omitempty"`
	HasDefault bool    `protobuf:"varint,5,opt,name=has_default,json=hasDefault" json:"has_default,omitempty"`
	HasMin     bool    `protobuf:"varint,6,opt,name=has_min,json=hasMin" json:"has_min,omitempty"`
	HasMax     bool    `protobuf:"varint,7,opt,name=has_max,json=hasMax" json:"has_max,omitempty"`
}

func (m *FloatRule) Reset()                    { *m = FloatRule{} }
func (m *FloatRule) String() string            { return proto.CompactTextString(m) }
func (*FloatRule) ProtoMessage()               {}
func (*FloatRule) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

type FloatPolicy struct {
	Rules map[string]*FloatRule `protobuf:"bytes,1,rep,name=rules" json:"rules,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Key   []string              `protobuf:"bytes,2,rep,name=key" json:"key,omitempty"`
}

func (m *FloatPolicy) Reset()                    { *m = FloatPolicy{} }
func (m *FloatPolicy) String() string            { return proto.CompactTextString(m) }
func (*FloatPolicy) ProtoMessage()               {}
func (*FloatPolicy) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *FloatPolicy) GetRules() map[string]*FloatRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

type IntegerRule struct {
	Required   bool  `protobuf:"varint,1,opt,name=required" json:"required,omitempty"`
	Minimum    int64 `protobuf:"varint,2,opt,name=minimum" json:"minimum,omitempty"`
	Maximum    int64 `protobuf:"varint,3,opt,name=maximum" json:"maximum,omitempty"`
	Default    int64 `protobuf:"varint,4,opt,name=default" json:"default,omitempty"`
	HasDefault bool  `protobuf:"varint,5,opt,name=has_default,json=hasDefault" json:"has_default,omitempty"`
	HasMin     bool  `protobuf:"varint,6,opt,name=has_min,json=hasMin" json:"has_min,omitempty"`
	HasMax     bool  `protobuf:"varint,7,opt,name=has_max,json=hasMax" json:"has_max,omitempty"`
}

func (m *IntegerRule) Reset()                    { *m = IntegerRule{} }
func (m *IntegerRule) String() string            { return proto.CompactTextString(m) }
func (*IntegerRule) ProtoMessage()               {}
func (*IntegerRule) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

type IntegerPolicy struct {
	Rules map[string]*IntegerRule `protobuf:"bytes,1,rep,name=rules" json:"rules,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Key   []string                `protobuf:"bytes,2,rep,name=key" json:"key,omitempty"`
}

func (m *IntegerPolicy) Reset()                    { *m = IntegerPolicy{} }
func (m *IntegerPolicy) String() string            { return proto.CompactTextString(m) }
func (*IntegerPolicy) ProtoMessage()               {}
func (*IntegerPolicy) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *IntegerPolicy) GetRules() map[string]*IntegerRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

type StringRule struct {
	Required   bool   `protobuf:"varint,1,opt,name=required" json:"required,omitempty"`
	Default    string `protobuf:"bytes,2,opt,name=default" json:"default,omitempty"`
	HasDefault bool   `protobuf:"varint,3,opt,name=has_default,json=hasDefault" json:"has_default,omitempty"`
}

func (m *StringRule) Reset()                    { *m = StringRule{} }
func (m *StringRule) String() string            { return proto.CompactTextString(m) }
func (*StringRule) ProtoMessage()               {}
func (*StringRule) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

type StringPolicy struct {
	Rules map[string]*StringRule `protobuf:"bytes,1,rep,name=rules" json:"rules,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Key   []string               `protobuf:"bytes,2,rep,name=key" json:"key,omitempty"`
}

func (m *StringPolicy) Reset()                    { *m = StringPolicy{} }
func (m *StringPolicy) String() string            { return proto.CompactTextString(m) }
func (*StringPolicy) ProtoMessage()               {}
func (*StringPolicy) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *StringPolicy) GetRules() map[string]*StringRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

type MetricsArg struct {
	Metrics []*Metric `protobuf:"bytes,1,rep,name=metrics" json:"metrics,omitempty"`
}

func (m *MetricsArg) Reset()                    { *m = MetricsArg{} }
func (m *MetricsArg) String() string            { return proto.CompactTextString(m) }
func (*MetricsArg) ProtoMessage()               {}
func (*MetricsArg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *MetricsArg) GetMetrics() []*Metric {
	if m != nil {
		return m.Metrics
	}
	return nil
}

type MetricsReply struct {
	Metrics []*Metric `protobuf:"bytes,1,rep,name=metrics" json:"metrics,omitempty"`
	Error   string    `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
}

func (m *MetricsReply) Reset()                    { *m = MetricsReply{} }
func (m *MetricsReply) String() string            { return proto.CompactTextString(m) }
func (*MetricsReply) ProtoMessage()               {}
func (*MetricsReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *MetricsReply) GetMetrics() []*Metric {
	if m != nil {
		return m.Metrics
	}
	return nil
}

type GetMetricTypesArg struct {
	Config *ConfigMap `protobuf:"bytes,1,opt,name=config" json:"config,omitempty"`
}

func (m *GetMetricTypesArg) Reset()                    { *m = GetMetricTypesArg{} }
func (m *GetMetricTypesArg) String() string            { return proto.CompactTextString(m) }
func (*GetMetricTypesArg) ProtoMessage()               {}
func (*GetMetricTypesArg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *GetMetricTypesArg) GetConfig() *ConfigMap {
	if m != nil {
		return m.Config
	}
	return nil
}

func init() {
	proto.RegisterType((*CollectArg)(nil), "rpc.CollectArg")
	proto.RegisterType((*CollectReply)(nil), "rpc.CollectReply")
	proto.RegisterType((*Empty)(nil), "rpc.Empty")
	proto.RegisterType((*ErrReply)(nil), "rpc.ErrReply")
	proto.RegisterType((*Time)(nil), "rpc.Time")
	proto.RegisterType((*NamespaceElement)(nil), "rpc.NamespaceElement")
	proto.RegisterType((*PubProcArg)(nil), "rpc.PubProcArg")
	proto.RegisterType((*Metric)(nil), "rpc.Metric")
	proto.RegisterType((*ConfigMap)(nil), "rpc.ConfigMap")
	proto.RegisterType((*KillArg)(nil), "rpc.KillArg")
	proto.RegisterType((*GetConfigPolicyReply)(nil), "rpc.GetConfigPolicyReply")
	proto.RegisterType((*BoolRule)(nil), "rpc.BoolRule")
	proto.RegisterType((*BoolPolicy)(nil), "rpc.BoolPolicy")
	proto.RegisterType((*FloatRule)(nil), "rpc.FloatRule")
	proto.RegisterType((*FloatPolicy)(nil), "rpc.FloatPolicy")
	proto.RegisterType((*IntegerRule)(nil), "rpc.IntegerRule")
	proto.RegisterType((*IntegerPolicy)(nil), "rpc.IntegerPolicy")
	proto.RegisterType((*StringRule)(nil), "rpc.StringRule")
	proto.RegisterType((*StringPolicy)(nil), "rpc.StringPolicy")
	proto.RegisterType((*MetricsArg)(nil), "rpc.MetricsArg")
	proto.RegisterType((*MetricsReply)(nil), "rpc.MetricsReply")
	proto.RegisterType((*GetMetricTypesArg)(nil), "rpc.GetMetricTypesArg")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion3

// Client API for Collector service

type CollectorClient interface {
	CollectMetrics(ctx context.Context, in *MetricsArg, opts ...grpc.CallOption) (*MetricsReply, error)
	GetMetricTypes(ctx context.Context, in *GetMetricTypesArg, opts ...grpc.CallOption) (*MetricsReply, error)
	Ping(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ErrReply, error)
	Kill(ctx context.Context, in *KillArg, opts ...grpc.CallOption) (*ErrReply, error)
	GetConfigPolicy(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetConfigPolicyReply, error)
}

type collectorClient struct {
	cc *grpc.ClientConn
}

func NewCollectorClient(cc *grpc.ClientConn) CollectorClient {
	return &collectorClient{cc}
}

func (c *collectorClient) CollectMetrics(ctx context.Context, in *MetricsArg, opts ...grpc.CallOption) (*MetricsReply, error) {
	out := new(MetricsReply)
	err := grpc.Invoke(ctx, "/rpc.Collector/CollectMetrics", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *collectorClient) GetMetricTypes(ctx context.Context, in *GetMetricTypesArg, opts ...grpc.CallOption) (*MetricsReply, error) {
	out := new(MetricsReply)
	err := grpc.Invoke(ctx, "/rpc.Collector/GetMetricTypes", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *collectorClient) Ping(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ErrReply, error) {
	out := new(ErrReply)
	err := grpc.Invoke(ctx, "/rpc.Collector/Ping", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *collectorClient) Kill(ctx context.Context, in *KillArg, opts ...grpc.CallOption) (*ErrReply, error) {
	out := new(ErrReply)
	err := grpc.Invoke(ctx, "/rpc.Collector/Kill", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *collectorClient) GetConfigPolicy(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetConfigPolicyReply, error) {
	out := new(GetConfigPolicyReply)
	err := grpc.Invoke(ctx, "/rpc.Collector/GetConfigPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Collector service

type CollectorServer interface {
	CollectMetrics(context.Context, *MetricsArg) (*MetricsReply, error)
	GetMetricTypes(context.Context, *GetMetricTypesArg) (*MetricsReply, error)
	Ping(context.Context, *Empty) (*ErrReply, error)
	Kill(context.Context, *KillArg) (*ErrReply, error)
	GetConfigPolicy(context.Context, *Empty) (*GetConfigPolicyReply, error)
}

func RegisterCollectorServer(s *grpc.Server, srv CollectorServer) {
	s.RegisterService(&_Collector_serviceDesc, srv)
}

func _Collector_CollectMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MetricsArg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CollectorServer).CollectMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Collector/CollectMetrics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CollectorServer).CollectMetrics(ctx, req.(*MetricsArg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Collector_GetMetricTypes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMetricTypesArg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CollectorServer).GetMetricTypes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Collector/GetMetricTypes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CollectorServer).GetMetricTypes(ctx, req.(*GetMetricTypesArg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Collector_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CollectorServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Collector/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CollectorServer).Ping(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Collector_Kill_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KillArg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CollectorServer).Kill(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Collector/Kill",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CollectorServer).Kill(ctx, req.(*KillArg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Collector_GetConfigPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CollectorServer).GetConfigPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Collector/GetConfigPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CollectorServer).GetConfigPolicy(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _Collector_serviceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.Collector",
	HandlerType: (*CollectorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CollectMetrics",
			Handler:    _Collector_CollectMetrics_Handler,
		},
		{
			MethodName: "GetMetricTypes",
			Handler:    _Collector_GetMetricTypes_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _Collector_Ping_Handler,
		},
		{
			MethodName: "Kill",
			Handler:    _Collector_Kill_Handler,
		},
		{
			MethodName: "GetConfigPolicy",
			Handler:    _Collector_GetConfigPolicy_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: fileDescriptor0,
}

// Client API for Processor service

type ProcessorClient interface {
	Process(ctx context.Context, in *PubProcArg, opts ...grpc.CallOption) (*MetricsReply, error)
	Ping(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ErrReply, error)
	Kill(ctx context.Context, in *KillArg, opts ...grpc.CallOption) (*ErrReply, error)
	GetConfigPolicy(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetConfigPolicyReply, error)
}

type processorClient struct {
	cc *grpc.ClientConn
}

func NewProcessorClient(cc *grpc.ClientConn) ProcessorClient {
	return &processorClient{cc}
}

func (c *processorClient) Process(ctx context.Context, in *PubProcArg, opts ...grpc.CallOption) (*MetricsReply, error) {
	out := new(MetricsReply)
	err := grpc.Invoke(ctx, "/rpc.Processor/Process", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processorClient) Ping(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ErrReply, error) {
	out := new(ErrReply)
	err := grpc.Invoke(ctx, "/rpc.Processor/Ping", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processorClient) Kill(ctx context.Context, in *KillArg, opts ...grpc.CallOption) (*ErrReply, error) {
	out := new(ErrReply)
	err := grpc.Invoke(ctx, "/rpc.Processor/Kill", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processorClient) GetConfigPolicy(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetConfigPolicyReply, error) {
	out := new(GetConfigPolicyReply)
	err := grpc.Invoke(ctx, "/rpc.Processor/GetConfigPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Processor service

type ProcessorServer interface {
	Process(context.Context, *PubProcArg) (*MetricsReply, error)
	Ping(context.Context, *Empty) (*ErrReply, error)
	Kill(context.Context, *KillArg) (*ErrReply, error)
	GetConfigPolicy(context.Context, *Empty) (*GetConfigPolicyReply, error)
}

func RegisterProcessorServer(s *grpc.Server, srv ProcessorServer) {
	s.RegisterService(&_Processor_serviceDesc, srv)
}

func _Processor_Process_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PubProcArg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessorServer).Process(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Processor/Process",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessorServer).Process(ctx, req.(*PubProcArg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Processor_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessorServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Processor/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessorServer).Ping(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Processor_Kill_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KillArg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessorServer).Kill(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Processor/Kill",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessorServer).Kill(ctx, req.(*KillArg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Processor_GetConfigPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessorServer).GetConfigPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Processor/GetConfigPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessorServer).GetConfigPolicy(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _Processor_serviceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.Processor",
	HandlerType: (*ProcessorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Process",
			Handler:    _Processor_Process_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _Processor_Ping_Handler,
		},
		{
			MethodName: "Kill",
			Handler:    _Processor_Kill_Handler,
		},
		{
			MethodName: "GetConfigPolicy",
			Handler:    _Processor_GetConfigPolicy_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: fileDescriptor0,
}

// Client API for Publisher service

type PublisherClient interface {
	Publish(ctx context.Context, in *PubProcArg, opts ...grpc.CallOption) (*ErrReply, error)
	Ping(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ErrReply, error)
	Kill(ctx context.Context, in *KillArg, opts ...grpc.CallOption) (*ErrReply, error)
	GetConfigPolicy(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetConfigPolicyReply, error)
}

type publisherClient struct {
	cc *grpc.ClientConn
}

func NewPublisherClient(cc *grpc.ClientConn) PublisherClient {
	return &publisherClient{cc}
}

func (c *publisherClient) Publish(ctx context.Context, in *PubProcArg, opts ...grpc.CallOption) (*ErrReply, error) {
	out := new(ErrReply)
	err := grpc.Invoke(ctx, "/rpc.Publisher/Publish", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publisherClient) Ping(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ErrReply, error) {
	out := new(ErrReply)
	err := grpc.Invoke(ctx, "/rpc.Publisher/Ping", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publisherClient) Kill(ctx context.Context, in *KillArg, opts ...grpc.CallOption) (*ErrReply, error) {
	out := new(ErrReply)
	err := grpc.Invoke(ctx, "/rpc.Publisher/Kill", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publisherClient) GetConfigPolicy(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetConfigPolicyReply, error) {
	out := new(GetConfigPolicyReply)
	err := grpc.Invoke(ctx, "/rpc.Publisher/GetConfigPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Publisher service

type PublisherServer interface {
	Publish(context.Context, *PubProcArg) (*ErrReply, error)
	Ping(context.Context, *Empty) (*ErrReply, error)
	Kill(context.Context, *KillArg) (*ErrReply, error)
	GetConfigPolicy(context.Context, *Empty) (*GetConfigPolicyReply, error)
}

func RegisterPublisherServer(s *grpc.Server, srv PublisherServer) {
	s.RegisterService(&_Publisher_serviceDesc, srv)
}

func _Publisher_Publish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PubProcArg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublisherServer).Publish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Publisher/Publish",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublisherServer).Publish(ctx, req.(*PubProcArg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Publisher_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublisherServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Publisher/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublisherServer).Ping(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Publisher_Kill_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KillArg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublisherServer).Kill(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Publisher/Kill",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublisherServer).Kill(ctx, req.(*KillArg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Publisher_GetConfigPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublisherServer).GetConfigPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Publisher/GetConfigPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublisherServer).GetConfigPolicy(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _Publisher_serviceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.Publisher",
	HandlerType: (*PublisherServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Publish",
			Handler:    _Publisher_Publish_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _Publisher_Ping_Handler,
		},
		{
			MethodName: "Kill",
			Handler:    _Publisher_Kill_Handler,
		},
		{
			MethodName: "GetConfigPolicy",
			Handler:    _Publisher_GetConfigPolicy_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: fileDescriptor0,
}

// Client API for StreamCollector service

type StreamCollectorClient interface {
	StreamMetrics(ctx context.Context, opts ...grpc.CallOption) (StreamCollector_StreamMetricsClient, error)
	GetMetricTypes(ctx context.Context, in *GetMetricTypesArg, opts ...grpc.CallOption) (*MetricsReply, error)
	Ping(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ErrReply, error)
	Kill(ctx context.Context, in *KillArg, opts ...grpc.CallOption) (*ErrReply, error)
	GetConfigPolicy(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetConfigPolicyReply, error)
}

type streamCollectorClient struct {
	cc *grpc.ClientConn
}

func NewStreamCollectorClient(cc *grpc.ClientConn) StreamCollectorClient {
	return &streamCollectorClient{cc}
}

func (c *streamCollectorClient) StreamMetrics(ctx context.Context, opts ...grpc.CallOption) (StreamCollector_StreamMetricsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_StreamCollector_serviceDesc.Streams[0], c.cc, "/rpc.StreamCollector/StreamMetrics", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamCollectorStreamMetricsClient{stream}
	return x, nil
}

type StreamCollector_StreamMetricsClient interface {
	Send(*CollectArg) error
	Recv() (*CollectReply, error)
	grpc.ClientStream
}

type streamCollectorStreamMetricsClient struct {
	grpc.ClientStream
}

func (x *streamCollectorStreamMetricsClient) Send(m *CollectArg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *streamCollectorStreamMetricsClient) Recv() (*CollectReply, error) {
	m := new(CollectReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *streamCollectorClient) GetMetricTypes(ctx context.Context, in *GetMetricTypesArg, opts ...grpc.CallOption) (*MetricsReply, error) {
	out := new(MetricsReply)
	err := grpc.Invoke(ctx, "/rpc.StreamCollector/GetMetricTypes", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamCollectorClient) Ping(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ErrReply, error) {
	out := new(ErrReply)
	err := grpc.Invoke(ctx, "/rpc.StreamCollector/Ping", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamCollectorClient) Kill(ctx context.Context, in *KillArg, opts ...grpc.CallOption) (*ErrReply, error) {
	out := new(ErrReply)
	err := grpc.Invoke(ctx, "/rpc.StreamCollector/Kill", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamCollectorClient) GetConfigPolicy(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetConfigPolicyReply, error) {
	out := new(GetConfigPolicyReply)
	err := grpc.Invoke(ctx, "/rpc.StreamCollector/GetConfigPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for StreamCollector service

type StreamCollectorServer interface {
	StreamMetrics(StreamCollector_StreamMetricsServer) error
	GetMetricTypes(context.Context, *GetMetricTypesArg) (*MetricsReply, error)
	Ping(context.Context, *Empty) (*ErrReply, error)
	Kill(context.Context, *KillArg) (*ErrReply, error)
	GetConfigPolicy(context.Context, *Empty) (*GetConfigPolicyReply, error)
}

func RegisterStreamCollectorServer(s *grpc.Server, srv StreamCollectorServer) {
	s.RegisterService(&_StreamCollector_serviceDesc, srv)
}

func _StreamCollector_StreamMetrics_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(StreamCollectorServer).StreamMetrics(&streamCollectorStreamMetricsServer{stream})
}

type StreamCollector_StreamMetricsServer interface {
	Send(*CollectReply) error
	Recv() (*CollectArg, error)
	grpc.ServerStream
}

type streamCollectorStreamMetricsServer struct {
	grpc.ServerStream
}

func (x *streamCollectorStreamMetricsServer) Send(m *CollectReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *streamCollectorStreamMetricsServer) Recv() (*CollectArg, error) {
	m := new(CollectArg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _StreamCollector_GetMetricTypes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMetricTypesArg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamCollectorServer).GetMetricTypes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.StreamCollector/GetMetricTypes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamCollectorServer).GetMetricTypes(ctx, req.(*GetMetricTypesArg))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamCollector_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamCollectorServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.StreamCollector/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamCollectorServer).Ping(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamCollector_Kill_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KillArg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamCollectorServer).Kill(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.StreamCollector/Kill",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamCollectorServer).Kill(ctx, req.(*KillArg))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamCollector_GetConfigPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamCollectorServer).GetConfigPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.StreamCollector/GetConfigPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamCollectorServer).GetConfigPolicy(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _StreamCollector_serviceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.StreamCollector",
	HandlerType: (*StreamCollectorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetMetricTypes",
			Handler:    _StreamCollector_GetMetricTypes_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _StreamCollector_Ping_Handler,
		},
		{
			MethodName: "Kill",
			Handler:    _StreamCollector_Kill_Handler,
		},
		{
			MethodName: "GetConfigPolicy",
			Handler:    _StreamCollector_GetConfigPolicy_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamMetrics",
			Handler:       _StreamCollector_StreamMetrics_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: fileDescriptor0,
}

func init() {
	proto.RegisterFile("github.com/intelsdi-x/snap/control/plugin/rpc/plugin.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 1532 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xdc, 0x58, 0x4b, 0x6f, 0xdb, 0xc6,
	0x16, 0x16, 0x4d, 0xbd, 0x78, 0x28, 0xf9, 0x31, 0xc8, 0xcd, 0xd5, 0x55, 0x12, 0x44, 0xa1, 0x6f,
	0x12, 0xe5, 0x71, 0xe5, 0x5c, 0x39, 0x75, 0x13, 0xa7, 0x5d, 0x38, 0xb1, 0x1b, 0x27, 0xa9, 0x53,
	0x83, 0x71, 0xb3, 0x29, 0xd0, 0x60, 0x24, 0x8f, 0x65, 0x22, 0x7c, 0x75, 0x48, 0x06, 0xf6, 0x5f,
	0xe8, 0xb6, 0xab, 0x02, 0x05, 0x0a, 0xf4, 0x17, 0x74, 0xdd, 0x55, 0x17, 0x5d, 0x14, 0xfd, 0x13,
	0xfd, 0x2b, 0xc5, 0x3c, 0x28, 0x0e, 0x29, 0x29, 0xb2, 0x17, 0x05, 0x82, 0xee, 0x78, 0x5e, 0x9f,
	0xce, 0xf9, 0xce, 0x99, 0x21, 0x8f, 0x60, 0x73, 0xe4, 0xc4, 0xc7, 0xc9, 0xa0, 0x37, 0x0c, 0xbc,
	0x35, 0xc7, 0x8f, 0x89, 0x1b, 0x1d, 0x3a, 0xff, 0x3b, 0x59, 0x8b, 0x7c, 0x1c, 0xae, 0x0d, 0x03,
	0x3f, 0xa6, 0x81, 0xbb, 0x16, 0xba, 0xc9, 0xc8, 0xf1, 0xd7, 0x68, 0x38, 0x94, 0x8f, 0xbd, 0x90,
	0x06, 0x71, 0x80, 0x74, 0x1a, 0x0e, 0xad, 0x9f, 0x35, 0x80, 0x27, 0x81, 0xeb, 0x92, 0x61, 0xbc,
	0x45, 0x47, 0xe8, 0x1e, 0x98, 0x7b, 0x24, 0xa6, 0xce, 0x30, 0x7a, 0xb3, 0x45, 0x47, 0x2d, 0xad,
	0xa3, 0x75, 0xcd, 0xfe, 0x52, 0x8f, 0x86, 0xc3, 0x9e, 0xd4, 0x6f, 0xd1, 0x91, 0x0d, 0xde, 0xf8,
	0x19, 0xf5, 0x00, 0xed, 0xe1, 0x13, 0x09, 0xb1, 0x9d, 0x50, 0x1c, 0x3b, 0x81, 0xdf, 0x5a, 0xe8,
	0x68, 0x5d, 0xdd, 0x46, 0xde, 0x84, 0x05, 0xdd, 0x86, 0xe5, 0x3d, 0x7c, 0x22, 0xc1, 0x1e, 0x27,
	0x47, 0x47, 0x84, 0xb6, 0x74, 0xee, 0xbd, 0xec, 0x15, 0xf4, 0xe8, 0x02, 0x54, 0xbe, 0x88, 0x8f,
	0x09, 0x6d, 0x95, 0x3b, 0x5a, 0xb7, 0x61, 0x57, 0x02, 0x26, 0x58, 0x6f, 0xa1, 0x21, 0x41, 0x6d,
	0x12, 0xba, 0xa7, 0x68, 0x03, 0x9a, 0x69, 0xce, 0x5c, 0x21, 0xb3, 0x5e, 0x51, 0xb3, 0xe6, 0x06,
	0xbb, 0xe1, 0x29, 0x12, 0x5a, 0x85, 0xca, 0x0e, 0xa5, 0x01, 0xe5, 0xc9, 0x9a, 0xfd, 0x26, 0xf7,
	0xdf, 0xa1, 0x54, 0xf8, 0x56, 0x08, 0xb3, 0x59, 0x35, 0xa8, 0xec, 0x78, 0x61, 0x7c, 0x6a, 0x75,
	0xa0, 0x9e, 0xda, 0x58, 0x5e, 0xdc, 0xca, 0x7f, 0xc9, 0x48, 0x5d, 0xef, 0x42, 0xf9, 0xc0, 0xf1,
	0x08, 0x5a, 0x06, 0x3d, 0x22, 0x43, 0x6e, 0xd3, 0x6d, 0xf6, 0x88, 0x10, 0x94, 0x7d, 0xa6, 0x12,
	0xac, 0xf0, 0x67, 0xeb, 0x6b, 0x58, 0x7e, 0x89, 0x3d, 0x12, 0x85, 0x78, 0x48, 0x76, 0x5c, 0xe2,
	0x11, 0x3f, 0x66, 0xb8, 0xaf, 0xb1, 0x9b, 0x90, 0x14, 0xf7, 0x1d, 0x13, 0x50, 0x07, 0xcc, 0x6d,
	0x12, 0x0d, 0xa9, 0x13, 0x8e, 0xa9, 0x35, 0x6c, 0xf3, 0x30, 0x53, 0x31, 0x7c, 0x86, 0xc5, 0x79,
	0x34, 0xec, 0xb2, 0x8f, 0x3d, 0x62, 0x7d, 0x05, 0xb0, 0x9f, 0x0c, 0xf6, 0x69, 0x30, 0x64, 0x5d,
	0xba, 0x0e, 0x35, 0xc9, 0x44, 0x4b, 0xeb, 0xe8, 0x5d, 0xb3, 0x6f, 0x2a, 0xec, 0xd8, 0x35, 0xc9,
	0x0b, 0xba, 0x01, 0xd5, 0x27, 0x81, 0x7f, 0xe4, 0x8c, 0x24, 0x27, 0x8b, 0xdc, 0x4b, 0xa8, 0xf6,
	0x70, 0x68, 0x57, 0x87, 0xfc, 0xd1, 0xfa, 0xa5, 0x02, 0x55, 0x11, 0x8b, 0xd6, 0xc1, 0x18, 0xd7,
	0x21, 0xb1, 0xff, 0xc5, 0xa3, 0x8a, 0xd5, 0xd9, 0x86, 0x9f, 0x6a, 0x50, 0x0b, 0x6a, 0xaf, 0x09,
	0x8d, 0xb2, 0x49, 0xa9, 0xbd, 0x13, 0xa2, 0x92, 0x81, 0xfe, 0xbe, 0x0c, 0xd0, 0x43, 0x40, 0x9f,
	0xe3, 0x28, 0xde, 0x3a, 0x7c, 0x47, 0x68, 0xec, 0x44, 0xe4, 0x90, 0x51, 0xcf, 0xe7, 0xc4, 0xec,
	0x1b, 0x3c, 0x86, 0x29, 0x6c, 0xe4, 0x4e, 0x38, 0xa1, 0x5b, 0x50, 0x3e, 0xc0, 0xa3, 0xa8, 0x55,
	0x51, 0x92, 0x15, 0xc5, 0xf4, 0x98, 0x7e, 0xc7, 0x8f, 0xe9, 0xa9, 0x5d, 0x8e, 0xf1, 0x28, 0x42,
	0x37, 0xc1, 0x60, 0x21, 0x51, 0x8c, 0xbd, 0xb0, 0x55, 0x2d, 0x82, 0x1b, 0x71, 0x6a, 0x63, 0x1d,
	0xf8, 0xd2, 0x77, 0xe2, 0x56, 0x4d, 0x74, 0x20, 0xf1, 0x9d, 0xb8, 0xd8, 0xb7, 0xfa, 0x64, 0xdf,
	0xae, 0x81, 0x19, 0xc5, 0xd4, 0xf1, 0x47, 0x6f, 0x0e, 0x71, 0x8c, 0x5b, 0x06, 0xf3, 0xd8, 0x2d,
	0xd9, 0x20, 0x94, 0xdb, 0x38, 0xc6, 0x68, 0x15, 0x1a, 0x47, 0x6e, 0x80, 0xe3, 0xf5, 0xbe, 0xf0,
	0x81, 0x8e, 0xd6, 0x5d, 0xd8, 0x2d, 0xd9, 0xa6, 0xd4, 0xe6, 0x9c, 0x36, 0xee, 0x0b, 0x27, 0xb3,
	0xa3, 0x75, 0xb5, 0xb1, 0xd3, 0xc6, 0x7d, 0xee, 0x74, 0x15, 0xc0, 0xf1, 0xc7, 0x38, 0x8d, 0x8e,
	0xd6, 0xad, 0xec, 0x96, 0x6c, 0x83, 0xeb, 0x14, 0x87, 0x14, 0xa3, 0xc9, 0xfa, 0x22, 0x1d, 0x32,
	0x84, 0xc1, 0x69, 0x4c, 0x22, 0xe1, 0xb0, 0xc8, 0xce, 0x24, 0x73, 0xe0, 0x3a, 0xee, 0x70, 0x05,
	0x8c, 0x41, 0x10, 0xb8, 0xc2, 0xbe, 0xd4, 0xd1, 0xba, 0xf5, 0xdd, 0x92, 0x5d, 0x67, 0x2a, 0x6e,
	0xbe, 0x06, 0x66, 0xa2, 0xa4, 0xb0, 0xdc, 0xd1, 0xba, 0x4d, 0x56, 0x6e, 0x92, 0xe5, 0x20, 0x5d,
	0xd2, 0x24, 0x56, 0x3a, 0x5a, 0xb7, 0x9c, 0xba, 0x88, 0x2c, 0xda, 0x1f, 0x83, 0x31, 0x6e, 0x13,
	0x3b, 0x6b, 0x6f, 0xc9, 0xa9, 0x3c, 0x2f, 0xec, 0x91, 0x9d, 0x21, 0x7e, 0x6c, 0xe4, 0x39, 0x11,
	0xc2, 0xe6, 0xc2, 0x03, 0xed, 0x71, 0x15, 0xca, 0x0c, 0xd4, 0xfa, 0x53, 0x07, 0x63, 0x3c, 0x50,
	0xa8, 0x0f, 0xd5, 0x67, 0x7e, 0xbc, 0x87, 0x43, 0x39, 0xbc, 0xed, 0xfc, 0xc0, 0xf5, 0x84, 0x51,
	0x0c, 0x45, 0xd5, 0xe1, 0x02, 0x7a, 0x04, 0xc6, 0x2b, 0xde, 0x22, 0x16, 0xb6, 0xc0, 0xc3, 0xae,
	0x14, 0xc2, 0xc6, 0x76, 0x11, 0x69, 0x44, 0xa9, 0x8c, 0x1e, 0x40, 0xfd, 0x33, 0xd6, 0x16, 0x16,
	0xab, 0xf3, 0xd8, 0xcb, 0x85, 0xd8, 0xd4, 0x2c, 0x42, 0xeb, 0x47, 0x52, 0x44, 0x1f, 0x41, 0xed,
	0x71, 0x10, 0xb8, 0x2c, 0xb0, 0xcc, 0x03, 0x2f, 0x15, 0x02, 0xa5, 0x55, 0xc4, 0xd5, 0x06, 0x42,
	0x6a, 0x3f, 0x04, 0x53, 0x29, 0x62, 0x1e, 0x65, 0xba, 0x42, 0x59, 0xfb, 0x13, 0x58, 0xcc, 0x17,
	0x72, 0x1e, 0xc2, 0xdb, 0x8f, 0xa0, 0x99, 0x2b, 0x65, 0x5e, 0xb0, 0xa6, 0x06, 0x6f, 0x42, 0x43,
	0x2d, 0x67, 0x5e, 0x6c, 0x5d, 0x89, 0xb5, 0xae, 0x41, 0xed, 0x85, 0xe3, 0xba, 0xec, 0xe2, 0xbb,
	0x08, 0x55, 0x9b, 0xe0, 0x28, 0xf0, 0x65, 0x64, 0x95, 0x72, 0x89, 0xdd, 0x60, 0x17, 0x9e, 0x92,
	0x58, 0x70, 0xb7, 0x1f, 0xb8, 0xce, 0xf0, 0xf4, 0x3d, 0x77, 0x3b, 0x7a, 0x0e, 0x26, 0x9f, 0xec,
	0x90, 0x7b, 0xca, 0x9e, 0xdf, 0xe2, 0xf4, 0x4f, 0x43, 0xe1, 0x9d, 0x10, 0xb2, 0x68, 0x06, 0x0c,
	0xc6, 0x0a, 0xb4, 0x27, 0x4f, 0x6b, 0x0a, 0x26, 0x86, 0xe0, 0xf6, 0x6c, 0x30, 0x4e, 0xa2, 0x8a,
	0x26, 0xce, 0xb5, 0x84, 0x7b, 0x05, 0x8b, 0xec, 0xcd, 0x3f, 0x22, 0x34, 0x05, 0x14, 0xc3, 0x71,
	0x77, 0x36, 0xe0, 0x33, 0xe1, 0xaf, 0x42, 0x36, 0x1d, 0x55, 0x87, 0xf6, 0xa1, 0x29, 0x6f, 0x26,
	0x89, 0x29, 0x2e, 0xcb, 0x3b, 0xb3, 0x31, 0xc5, 0x9c, 0xa8, 0x90, 0x8d, 0x48, 0x51, 0xb5, 0x5f,
	0xc2, 0x52, 0x81, 0x94, 0x29, 0x2d, 0xbd, 0xae, 0xb6, 0x34, 0xfd, 0xf0, 0xc8, 0xc2, 0xd4, 0xf9,
	0xd8, 0x87, 0xe5, 0x22, 0x2f, 0x53, 0x00, 0x6f, 0xe4, 0x01, 0x97, 0x39, 0xa0, 0x12, 0xa7, 0x22,
	0x1e, 0x00, 0x9a, 0x24, 0x66, 0x0a, 0x66, 0x37, 0x8f, 0x89, 0x38, 0x66, 0x2e, 0x52, 0x45, 0xb5,
	0x61, 0x65, 0x82, 0x9a, 0x29, 0xa0, 0x37, 0xf3, 0xa0, 0xe2, 0xe3, 0x45, 0x0d, 0x54, 0xe7, 0x1b,
	0x43, 0x9d, 0x91, 0x62, 0x27, 0x2e, 0x41, 0x6d, 0xa8, 0x53, 0xf2, 0x4d, 0xe2, 0x50, 0x72, 0xc8,
	0xf1, 0xea, 0xf6, 0x58, 0x66, 0xaf, 0xd9, 0x43, 0x72, 0x84, 0x13, 0x37, 0x96, 0x67, 0x24, 0x15,
	0xd1, 0x55, 0x30, 0x8f, 0x71, 0xf4, 0x26, 0xb5, 0xea, 0xdc, 0x0a, 0xc7, 0x38, 0xda, 0x16, 0x1a,
	0xeb, 0x7b, 0x0d, 0x20, 0x23, 0x1e, 0xdd, 0x83, 0x0a, 0x4d, 0x5c, 0x12, 0xe5, 0x2e, 0xc9, 0xcc,
	0xde, 0x63, 0xa9, 0xc8, 0x37, 0xa7, 0x70, 0x4c, 0x4b, 0x64, 0x27, 0x45, 0x94, 0xd8, 0x7e, 0x0a,
	0x90, 0xb9, 0x4d, 0xa1, 0x60, 0x35, 0x4f, 0x41, 0x73, 0xfc, 0x1b, 0x2c, 0x4a, 0x2d, 0xff, 0x77,
	0x0d, 0x0c, 0xde, 0xc3, 0xb3, 0x10, 0xe0, 0x39, 0xbe, 0xe3, 0x25, 0x9e, 0xbc, 0x60, 0x52, 0x91,
	0x5b, 0xf0, 0x09, 0xb7, 0xe8, 0xd2, 0x22, 0x44, 0x95, 0xb4, 0xb2, 0xb0, 0xcc, 0x20, 0xad, 0x52,
	0x24, 0x0d, 0xfd, 0x1b, 0x6a, 0xcc, 0xc1, 0x73, 0x7c, 0xfe, 0xb1, 0x50, 0xb7, 0xab, 0xc7, 0x38,
	0xda, 0x73, 0xfc, 0xb1, 0x01, 0x9f, 0xf0, 0x2f, 0x04, 0x69, 0xc0, 0x27, 0xd6, 0x0f, 0x1a, 0x98,
	0xca, 0x38, 0xa2, 0xff, 0xe7, 0x79, 0xbe, 0x54, 0x9c, 0xd7, 0x33, 0x11, 0xbd, 0x3b, 0x87, 0xe8,
	0xff, 0xe6, 0x89, 0x5e, 0xcc, 0x7e, 0xa4, 0xc8, 0xf4, 0x1f, 0x1a, 0x7f, 0x77, 0xb0, 0xc9, 0x3e,
	0x2f, 0xd7, 0xfa, 0x4c, 0xae, 0xf5, 0x99, 0x5c, 0xeb, 0x7f, 0x2b, 0xd7, 0x3f, 0x69, 0xd0, 0xcc,
	0x1d, 0x53, 0xb4, 0x9e, 0x67, 0xfb, 0xca, 0xe4, 0x49, 0x3e, 0x13, 0xdf, 0xcf, 0xe7, 0xf0, 0x3d,
	0xf5, 0x12, 0x52, 0x68, 0x55, 0x19, 0x1f, 0x02, 0x88, 0x53, 0x7f, 0xde, 0xc3, 0x6d, 0x9c, 0xe3,
	0x70, 0xff, 0xa8, 0x41, 0x43, 0xbd, 0x5b, 0x50, 0x3f, 0x4f, 0xc4, 0xe5, 0x89, 0xdb, 0xe7, 0x4c,
	0x3c, 0x3c, 0x9b, 0xc3, 0xc3, 0xd4, 0xdb, 0x3d, 0xab, 0x56, 0xa5, 0x61, 0x1d, 0x20, 0xdb, 0x37,
	0xd9, 0xf6, 0xe2, 0xcd, 0xdf, 0x5e, 0xac, 0x17, 0xd0, 0x50, 0xd7, 0xbd, 0x33, 0x86, 0x65, 0x6f,
	0xfc, 0x05, 0x75, 0x9b, 0x7b, 0x04, 0x2b, 0x4f, 0x49, 0x2c, 0x7c, 0x0f, 0x4e, 0x43, 0xc2, 0x13,
	0xb9, 0x01, 0x72, 0xff, 0x90, 0x3b, 0xe6, 0x8c, 0xed, 0xa4, 0xff, 0xed, 0x02, 0xfb, 0xc4, 0xe4,
	0x3b, 0x6a, 0x40, 0xd1, 0x06, 0x2c, 0x4a, 0x41, 0xa6, 0x87, 0x8a, 0x1b, 0x75, 0x7b, 0x72, 0x59,
	0xb5, 0x4a, 0xe8, 0x53, 0x58, 0xcc, 0xa7, 0x80, 0x2e, 0xa6, 0xef, 0xdf, 0x7c, 0x5e, 0xd3, 0xc3,
	0x57, 0xa1, 0xbc, 0xef, 0xf8, 0x23, 0x04, 0x62, 0xb1, 0x65, 0x5b, 0x6c, 0x3b, 0xbf, 0xe4, 0x5a,
	0x25, 0x74, 0x1d, 0xca, 0xec, 0x53, 0x09, 0x35, 0xb8, 0x41, 0x7e, 0x35, 0x4d, 0xba, 0x6d, 0xc2,
	0x52, 0xe1, 0xad, 0x9f, 0x83, 0xfd, 0xcf, 0xcc, 0xef, 0x02, 0xab, 0xd4, 0xff, 0x4d, 0x03, 0x83,
	0xed, 0xa1, 0x24, 0x8a, 0x02, 0x8a, 0xd6, 0xa0, 0x26, 0x05, 0xc9, 0x42, 0xb6, 0xa5, 0x7e, 0xd8,
	0x65, 0xfc, 0xca, 0xca, 0x48, 0x06, 0xae, 0x13, 0x1d, 0x13, 0x8a, 0xee, 0x40, 0x4d, 0x0a, 0x93,
	0x65, 0x4c, 0xfc, 0xec, 0x87, 0x52, 0xc2, 0x77, 0x0b, 0xb0, 0xf4, 0x2a, 0xa6, 0x04, 0x7b, 0xd9,
	0x70, 0x3e, 0x84, 0xa6, 0x50, 0xe5, 0x67, 0x33, 0xfb, 0x4f, 0x48, 0x76, 0x45, 0xfd, 0xcb, 0xc5,
	0x2a, 0x75, 0xb5, 0x7b, 0xda, 0x3f, 0x64, 0x3e, 0x07, 0x55, 0xfe, 0x77, 0xd8, 0xfa, 0x5f, 0x01,
	0x00, 0x00, 0xff, 0xff, 0x04, 0x49, 0xf2, 0x93, 0x4c, 0x13, 0x00, 0x00,
}
